<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Caching system</title>
  <meta name="description" content="  Comparison between Redis and Memcached          Value types      Memory efficiency      Scaling      Eviction policy        LRU implementationComparison be...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="stylesheet" type="text/css" href="/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->

  <link rel="canonical" href="/articles/18/caching-system">

  <link rel="alternate" type="application/rss+xml" title="Tufte-Jekyll" href="/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<a href="/"><img class="badge" src="/assets/img/badge_1.png" alt="CH"></a>
	
		
  	
		
		    
		      <a href="/">blog</a>
		    
	    
  	
		
		    
		      <a href="/about/">About</a>
		    
	    
  	
		
		    
		      <a href="/page/">page</a>
		    
	    
  	
		
		    
		      <a href="/css/print.css"></a>
		    
	    
  	
		
  	
	</nav>
</header>
    <article class="group">
      <h1>Caching system</h1>
<p class="subtitle">November 4, 2018</p>

<ul id="markdown-toc">
  <li><a href="#comparison-between-redis-and-memcached" id="markdown-toc-comparison-between-redis-and-memcached">Comparison between Redis and Memcached</a>    <ul>
      <li><a href="#value-types" id="markdown-toc-value-types">Value types</a></li>
      <li><a href="#memory-efficiency" id="markdown-toc-memory-efficiency">Memory efficiency</a></li>
      <li><a href="#scaling" id="markdown-toc-scaling">Scaling</a></li>
      <li><a href="#eviction-policy" id="markdown-toc-eviction-policy">Eviction policy</a></li>
    </ul>
  </li>
  <li><a href="#lru-implementation" id="markdown-toc-lru-implementation">LRU implementation</a></li>
</ul>

<h2 id="comparison-between-redis-and-memcached">Comparison between Redis and Memcached</h2>

<p>In almost every system, there is some benefit to cache the results of some queries. Often this is done in memory, using either Memcached or Redis. Redis seems to be the goto solution as of 2018 as it is not just a key-value store, but a data structure store.</p>

<p>This <a href="https://www.linkedin.com/pulse/memcached-vs-redis-which-one-pick-ranjeet-vimal/">post</a> by Ranjeet Vimal has a nice comparison between Memcached and Redis.</p>

<h3 id="value-types">Value types</h3>
<p>Memcached value type is essentially a simple byte array. It is great for small, static data like HTML code fragments. Redis value type can be lists, sorted sets, hashes etc, which are much more dynamic and powerful.</p>

<h3 id="memory-efficiency">Memory efficiency</h3>
<p>Due to the simpler value type, Memcached is more memory efficient than Redis.</p>

<h3 id="scaling">Scaling</h3>
<p>Memcached is multithreaded and easier to scale for beginners. Redis is single-threaded (which gives you more control) and needs sharding which is more complex to setup.</p>

<h3 id="eviction-policy">Eviction policy</h3>
<p>Memcached only supports LRU. Lazy eviction whereas Redis allows more fine-grained control. Redis supports at least 6 different eviction policies. It also supports both lazy and active eviction.</p>

<h2 id="lru-implementation">LRU implementation</h2>

<p>LRU stands for Least Recently Used and is a very widely used eviction strategy. Typically it is implemented using a queue. Every time an element is accessed, it is moved to the front of the queue. During eviction, we remove elements at the end of the queue. Some details can be found at <a href="https://www.geeksforgeeks.org/lru-cache-implementation/">GeeksforGeeks</a>.</p>

<p>However, this exact implementation of LRU costs a lot of memory as the size of the queue grows with the number of keys. It is very common to instead sample a few keys (say 5) and then evict the key with the largest timestamps.</p>



    </article>
    <span class="print-footer">Caching system - November 4, 2018 - clay harmon</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    <li><a href="mailto:hate@spam.net"><span class="icon-mail"></span></a></li>    
    
      <li>
        <a href="//www.twitter.com/twitter_handle"><span class="icon-twitter"></span></a>
      </li>
    
      <li>
        <a href="//plus.google.com/+googlePlusName"><span class="icon-googleplus"></span></a>
      </li>
    
      <li>
        <a href="//github.com/GithubHandle"><span class="icon-github"></span></a>
      </li>
    
      <li>
        <a href="//www.flickr.com/photos/FlickrUserID"><span class="icon-flickr"></span></a>
      </li>
    
      <li>
        <a href="/feed"><span class="icon-feed"></span></a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2018 &nbsp;&nbsp;CLAY HARMON</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme for Content-centric blogging </a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  </body>
</html>
